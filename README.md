1. `cd` is a shell builtin

2. `grep <some_string> <some_file> -c`

3. `/sbin/init`

4. `ls /*wrong_dir* 2> /dev/pts/*any_session*`

5. `hello < test1 > test2`

6. Получится вывести перенаправлением потока в /dev/tty.

7. Команда `bash 5>&1` создаст новый файловый дескриптор 5 с потоком stdout. Команда `echo netology > /proc/$$/fd/5` выводит созданный файловый дескриптор 5 с потоком stdout. 

8. Вывод stderr в файл 
```
bash 3>&1
ls /123 2>&1 >/proc/$$/fd/3 | cat>example.txt
```
9. Команда выведет переменные окружения, также вывести можно командой env

10. По адресу /proc/<PID>/cmdline находится файл доступный только для чтения, содержит полную командную строку для процесса, если только процесс не является зомби. Адрес /proc/<PID>/exe представляет собой символическую ссылку, содержащую фактический путь к исполняемой команде.

11. SSE 4.2

12. `ssh -t localhost 'tty'` - запустить ssh с обязательным выделением псевдо-терминала

13. Запустил ping localhost, убрал процесс в background при помощи ctrl+z, 
```
disown ping
screen
reptyr *pid*
```

14. команда tee считывает из stdin и записывает в stdout или в файл. Проблема в том, что shell выполняет перенаправление вывода, а не sudo или echo. В случае с командой `echo string | sudo tee /root/new_file` команда tee принимает на вход stdout через pipe и выполняется из под sudo.
